1. 중복되는 연산을 줄이자!
    - 현실세계에는 다양한 문제가 있다. 그 중 컴퓨터로 해결하기 어려운 문제는?
        - 최적의 해를 구하기에 시간이 매우 많이 필요한 문제
        - 최적의 해를 구하기에 메모리 공간이 매우 많이 필요한 문제
            - 컴퓨터는 연산속도에 한계
            - 메모리 공간을 사용할 수 있는 데이터의 개수도 한정
    - 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있는 방법
        - 다이나믹 프로그래밍(동적 계획법)

        ![다이나믹프로그래밍](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a8c4116a-eabc-4e18-b2e4-e9449c838439/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210402%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210402T130304Z&X-Amz-Expires=86400&X-Amz-Signature=1d37cfcbec86388da63430dec48b97cf1e6f3928139cfe9a349e9b97eddba7f8&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

        - 위 그림처럼 피보나치 수열이 대표적 예시 (중복된 계산이 많을때 사용된다)

            ```python
            # 피보나치 함수를 재귀함수로 구현
            def fibo(x):
            		if x == 1 or x == 2:
            				return 1
            		return fibo(x - 1) + fibo(x - 2)

            print(fibo(4))
            ```

            - 항상 다이나믹 프로그래밍을 사용할수 없음
            - 조건
                1. 큰 문제를 작은 문제로 나눌수 있다.
                2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
            - 메모이제이션 기법을 사용해서 해결
                - 한번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법
                - 자세한 사항 [이곳](https://www.zerocho.com/category/Algorithm/post/584b979a580277001862f182)참조
        - 피보나치 수열 (재귀적) → 다이나믹
    - 피보나치 수열을 통한 예시
        1. 재귀적 표현(탑 다운 방식) - 하향식

            ```python
            # 한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화
            d = [0] * 100

            # 피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
            def fibo(x):
            		# 종료 조건(1 혹은 2일 때 1을 반환)
            		print('f(' + str(x) + ')', end = ' ')
            		if x == 1 or x == 2:
            			return 1
            		# 이미 계산한 적 있는 문제라면 그대로 반환
            		if d[x] != 0:
            			return d[x]
            		# 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
            		d[x] = fibo(x - 1) + fibo(x - 2)
            		return d[x]

            print(fibo(99))
            ```

        2. 반복적 표현(보텀업 방식) - 상향식 (전형적인 형태)

            ```python
            # 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
            d = [0] * 100

            # 첫 번째 피보나치 수와 두번 째 피보나치 수는 1
            d[1] = 1
            d[2] = 1
            n = 99

            # 피보나치 함수를 반복문으로 구현(보텀업 다이나믹 프로그래밍)
            for i in range(3, n + 1):
            	d[i] = d[i - 1] + d[i - 2]

            print(d[n])
            ```

    - 문제푸는 요령
        1. 주어진 문제가 다이나믹 프로그래밍 유형임을 파악(당연한 것)
            - 완전 탐색으로 접근했는데 시간이 오래걸리면 다이나믹 적용가능한지 부분 문제들이 중복여부 확인
        2. 단순히 재귀함수로 작성한뒤 나중에 메모이제이션 기법을 적용하여 소스코드 수정 
        3. 탑다운(재귀)보단 보텀업(반복)을 사용하여 구현하는것이 좋다 
            - 시스템상 재귀함수의 스택 크기가 한정될 수 있기 때문에
2. 문제 예시 
    1. 1로 만들기 

        ```
        입력조건
        1. 첫째 줄에 정수 x가 주어진다(1 <= x <= 30.000)
        출력조건
        1. 첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

        입력 예시
        26
        출력 예시
        3 

        ```

       > 이 문제는 잘 알려진 다이나믹 프로그래밍 문제 

        ```python
        # 정수 x를 입력받기
        x = int(input())

        # 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
        d = [0] * 100

        # 다이나믹 프로그래밍 진행(보텀업-반복적)
        for i in range(2, x + 1):
        		# 현재의 수에서 1을 빼는 경우
        		d[i] = d[i - 1] + 1
        		# 현재의 수에서 2로 나누어 떨어지는 경우
        		if i % 2 == 0:
        			d[i] = min(d[i],d[i//2]+1)
        		# 현재의 수가 3으로 나누어 떨어지는 경우
        		if i % 3 == 0:
        			d[i] = min(d[i],d[i//3]+1)
        		# 현재의 수가 5로 나누어 떨어 지는 경우
        		if i % 5 == 0:
        			d[i] = min(d[i],d[i//5]+1)
        	
        print(d[x])
        ```

    2. 개미 전사

        ```
        입력조건
        1. 첫째 줄에 식량창고의 개수 N이 주어진다. (3<= N <= 100)
        2. 둘째 줄에 공백으로 구분되어 각 식량창고에 저장된 식량의 개수 K가 주어진다. (0<= K <=1,000)

        출력조건
        1. 첫째 줄에 개미 전사가 얻을 수 있는 식량의 최댓값을 출력하시오.

        입력예시
        4
        1 3 1 5
        출력예시
        8
        ```

        >점화식을 세워서 쉽게 해결 가능
        >1. 왼쪽부터 차례대로 식량창고를 털지 안털지를 결정하는 경우
        >2. 특정한 i번째 식량창고에 대해서 털지 안털지의 여부 결정
        (i-3)번째 이하의 식량 창고에 대해서는 고려x → 한칸 떨어진 식량창고는 항상 털 수 있으므로

        ```python
        # 정수 N을 입력받기
        n = int(input())
        # 모든 식량 정보 입력받기
        array = list(map(int, input().split()))

        # 앞서 계산된 결과를 저장하기 위한 DP테이블 초기화
        d = [0] * 100

        # 다이나믹 프로그래밍 진행(보텀업)
        d[0] = array[0]
        d[1] = max(array[0], array[1])
        for i in range(2, n):
        		d[i] = max(d[i - 1], d[i - 2] + array[i])

        print(d[n-1])
        ```

    3. 바닥공사

        ```
        입력조건
        1. 첫째 줄에 N이 주어진다. (1 <= N <= 1,000)
        출력조건
        1. 첫째 줄에 2 x N 크기의 바닥을 채우는 방법의 수를 796,796으로 나눈 나머지를 출력한다

        입력예시
        3
        출력예시
        5
        ```

        >다이나믹 기초 예제에서 빠질수 없는 문제
        값을 계산할때 특정한 수로 나눈 나머지만 취하도록 하면 됨

        ```python
        # 정수 N을 입력받기
        n = int(input())

        # 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
        d = [0] * 1001

        # 다이나믹 프로그래밍 진행(보텀업)
        d[1] = 1
        d[2] = 3
        for i in range(3, n+1):
        		d[i] = (d[i - 1] + 2 * d[i - 2]) % 796796

        print(d[n])
        ```

    4. 효율적인 화폐 구성

        ```
        입력조건
        1. 첫째 줄에 N,M이 주어진다 (1 <= N <= 100, 1 <= M <= 10,000)
        2. 이후의 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐의 가치는 10,000 보다 작거나 같은 자연수이다.

        출력조건
        1. 첫째 줄에 경우의 수 x를 출력한다.
        2. 불가능할 때는 -1을 출력한다.

        입력예시1
        2 15
        2
        3
        출력예시1
        5
        입력예시2
        3 4
        3
        5
        7
        출력예시
        -1
        ```

        >그리디의 거스름돈 문제와 거의 동일
        단지 화폐단위에서 큰 단위가 작은 단위의 배수가 아니라는 점만 다름
        그래서 다이나믹 프로그래밍을 이용해야한다. 
        적은 금액부터 큰 금액까지 확인하며 차례대로 만들 수 있는 최소한의 화폐 개수를 찾으면된다.

        ```python
        # 정수 N, M을 입력받기
        n, m = map(int, input().split())
        # N개의 화폐 단위정보를 입력받기
        array = []
        for i in range(n):
        		array.append(int(input()))

        # 한 번 계산된 결과를 저장하기 위한 DP테이블 초기화
        d = [10001] * (m + 1)

        # 다이나믹 프로그래밍 진행(보텀업)
        d[0] = 0
        for i in range(n):
        		for j in range(array[i], m + 1):
        				if d[j - array[i]] != 10001: # (i - k)원을 만드는 방법이 존재하는 경우
        						d[j] = min(d[j], d[j - array[i]] + 1)

        # 계산된 결과 출력
        if d[m] == 10001: # 최종적으로 M원을 만드는 방법이 없는경우
        		print(-1)
        else:
        		print(d[m])
        ```